# JavaScript 程序设计

## HTML 中的 JavaScript

**`<script>`元素**
- `<script>`元素可以包含来自外部域的 JavaScript 文件
- `defer`属性
    - 按照 HTML5 规范要求脚本应该按照它们出现的顺序执行
    - 并且会在 DOMContentLoaded 事件之前执行
- `async`属性
    - 标记为异步的脚本并不保证能按照它们出现的次序执行

**动态加载脚本**
- 默认情况下，以这种方式创建的`<script>`元素相当于加了`async`属性

**`<noscript>`元素**
- 在浏览器不支持脚本或对脚本的支持被关闭时显示包含在`<noscript>`中的内容

## ECMAScript

**严格模式**
- 在脚本开头加上`'use strict'`
- 在函数体开头加上`'use strict'`，单独指定一个函数在严格模式下执行

**变量**
- `var`声明
    - 省略`var`初始化变量会在函数内创建全局变量，在严格模式下会抛出错误
    - `var`存在着声明提升，也因此可以反复多次使用`var`声明同一个变量
- `let`声明
    - 与`var`的函数作用域不同，`let`是块作用域
    - `let`不允许同一个块作用域中出现冗余声明
    - `let`不存在声明提升，在`let`声明之前的执行瞬间被成为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出错误
    - 与`var`不同，使用`let`在全局作用域中声明的变量不会成为`window`对象的属性
    - `let`在每次迭代声明一个独立变量实例
- `const`声明
    - 声明变量时必须同时初始化变量，尝试修改`const`声明的变量会抛出错误
    - 如果`const`变量引用的是一个对象，那么修改这个对象内部的属性并不违反`const`的限制
- 最佳实践
    - 不使用`var`
    - `const`优先，`let`次之

**字符串**
- ECMAScript 中的字符串是不可变的
- `toString()`方法
    - `null`和`undefined`值没有`toString()`方法
    - 数值调用这个方法时，可以传入一个底数参数
- `String()`函数
    - 如果值有`toString()`方法，调用该方法
    - 如果值是`null`，返回`'null'`
    - 如果值是`undefined`，返回`'undefined'`
- 模板字面量
    - 模板字面量会保持反引号内部的空格和换行符
    - 模板字面量支持字符串插值，在定义时立即求值并转化为字符串实例
    - 模板字面量支持定义标签函数
        - 可以使用默认的`String.raw()`标签函数获取原始的模板字面量内容
        ```javascript
        console.log(String.raw`\u00A9`);
        ```
        - 也可以通过标签函数的第一个参数，即字符串数组的`.raw`属性取得每个字符串的原始内容

**Symbol 类型**
- 基本用法
    - 使用`Symbol()`函数进行初始化
    - 可以传入一个字符串参数作为对符号的描述
- 全局符号注册表
    - `Symbol.for()`方法
        - 根据传入的字符串检查注册表，发现不存在对应的符号，生成新符号
        - 发现对应的符号，返回该符号
    - 采用相同的描述，在全局注册表中定义的符号跟使用`Symbol()`定义的符号也并不相同
    - `Symbol.keyFor()`方法
        - 接收符号，返回该全局符号对应的字符串键
- 内置符号

**操作符**
- 在应用给对象时，操作符通常会调用`valueOf()`和`toString()`方法来取得可以计算的值
- 一元操作符
    - 前缀，变量的值会在语句被求值之前改变
    - 后缀，在语句求值后才发生
- 位操作符
    - 确定负数的补码
        1. 确定绝对值的二进制表示
        2. 找到数值的反码
        3. 给结果加 1
    - `~`按位非、`&`按位与、`|`按位或、`^`按位异或
    - `<<`左移、`>>`无符号右移、`>>>`有符号右移
- 布尔操作符
    - `!`逻辑非、`&&`逻辑与、`||`逻辑或
    - `&&`和`||`具有短路特性
    ```javascript
    let myObject = preferredObject || backupObject;
    //如果第一个变量未定义，则赋值第二个变量
    ```
- 加性操作符
    - 如果两个操作数都是数值，执行加法运算
    - 如果两个操作数都是字符串，执行拼接
    - 如果有一个操作数是字符串，对另一个操作数执行`toString()`方法后进行拼接
- 关系操作符
    - 如果任一操作数是数值，执行数值比较
    - 如果操作数都是字符串，比较编码
    - 涉及比较`NaN`时都返回`false`
- 相等操作符
    - `==`进行类型转换
        - 类似关系操作符
        - `null`和`undefined`相等
        - 如果两个操作数指向同一个对象则相等
        - `null`和`undefined`不进行类型转换
    - `===`不进行类型转换
    - 推荐使用全等操作符，保持数据类型的完整性
    - 涉及比较`NaN`时都返回`false`

**语句**
- for-in 语句
    - 枚举对象中的非符号键属性
    - 不保证返回对象属性的顺序
- for-of 语句
    - 遍历可迭代对象的元素
    - 按照`next()`方法产生迭代值的顺序
- 标签语句
    - 配合`break`、`continue`能实现复杂的逻辑
- with 语句
    - 严格模式下不允许使用 with 语句
    - 不推荐使用 with 语句
- switch 语句
    - 不使用`break`，代码会匹配下一个条件
    - 可以用于所有数据类型，判断时不会进行类型转换

**原始值、引用值**
- 保存原始值的变量是按值访问的，保存引用值的变量是按引用访问的
- 只有引用值可以动态添加后面可以使用的属性
- 引用值实际上是一个指针，它指向存储在堆内存中的对象
- ECMAScript 中所有函数的参数都是按值传递的
- 可以使用`instanceof`操作符知道一个引用值是什么类型的对象
    - 如果变量是给定引用类型的实例，则`instanceof`操作符返回`true`
    ```javascript
    result = variable instanceof constructor
    ```

**执行上下文**
- 每个上下文都有一个关联的变量对象
    - 每个函数调用都有自己的上下文
    - 上下文代码在执行时，会创建变量对象的一个作用域链
- 上下文在所有代码执行完毕后会被销毁
- 主要有全局上下文和函数上下文两种
    - 使用 try/catch 语句的`catch`块，创建一个新的变量对象， 包含要抛出的错误对象的声明
    - `with`语句，向作用域链前端添加新的对象
