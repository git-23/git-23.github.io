**迭代器和生成器**
- 计数循环就是一种最简单的迭代
    - 迭代之前需要如何使用数据结构
    - 遍历顺序并不是数据结构固有的
- `Array.prototype.forEach()`
    - 解决了单独记录索引和通过数组对象取得值的问题
    - 没有办法表示迭代何时终止
    - 只适用于数组
    - 回调结构笨拙

**迭代器模式**
- 把有些结构称为'可迭代对象'，因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费
- 可以把可迭代对象理解成数组或集合这样集合类型的对象
    - 它们包含的元素都是有限的，而且都具有无歧义的遍历顺序
    - 可迭代对象不一定是集合对象，如计数循环， 临时性可迭代对象可以实现为生成器
- 任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构消费
- 实现 Iterable 接口要求同时具备两种能力
    - 支持迭代的自我识别能力
    - 创建实现 Iterator 接口的对象的能力
- 字符串、数组、映射、集合、arguments对象、DOM 集合属性都实现了 Iterable 接口
- 实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性
    - for-of 循环、数组解构、扩展操作符、`Array.from()`、创建集合、创建映射、`Promise.all()`、`Promise.race()`、yield 操作符
    - 这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器
- 如果对象原型链上的父类实现了 Iterable 接口，那这个对象也就实现了这个接口

**迭代器**
- 每次成功调用`next()`，都会返回一个`iteratorResult`对象
    - `done`表示是否还可以再次调用`next()`取得下一个值
    - `value`包含可迭代对象的下一个值或`undefined`
- 只要迭代器到达 done: true 状态，后续调用`next()`就返回一样的值了
- 每个迭代器都代表对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系
- 迭代器并不与可迭代对象某个时刻的快照绑定
    - 如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化
    - 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象

**自定义迭代器**
- 任何实现了 Iterator 接口的对象都可以作为 迭代器使用
- 一个可迭代对象能够创建多个迭代器            
- 提前终止迭代器
    - 可能情况
        - for-of 循环通过语句退出
        - 解构操作并未消费所有值
    - 可选的`return()`方法用于指定在迭代器提前关闭时的逻辑
        - 要知道迭代器是否可关闭，可以测试实例的`return`属性是不是函数
        - 给不可关闭的迭代器增加`return()`方法不能让它变成可关闭的
        - 调用`return()`方法不会强制迭代器进入关闭状态

**生成器**
- 定义
    - 拥有在函数块内暂停和恢复代码执行的能力
- 用途
    - 使用生成器自定义迭代器
    - 实现协程
- 形式
    - 一个函数，函数名称前面加一个星号(`*`)  
    - 箭头函数不能被用来定义生成器函数
    - 标识生成器函数的星号不受两侧空格影响
- 执行
    - 调用生成器函数会产生一个生成器对象
        - 生成器对象一开始处于暂停执行的状态
        - 生成器也实现了 Iterator 接口，具有`next()`方法
    - 调用`next()`方法会让生成器开始或恢复执行
        - `next()`方法返回值类似迭代器，具有`done`和`value`属性
        - `value()`属性是生成器函数的返回值
    - 生成器函数在遇到`yield`关键字后会停止执行
        - 通过`yield`退出，`done: false`
        - 通过`return`退出，`done: true`
        - `yield`关键字必须直接位于生成器函数定义中
- 使用
    - 把生成器对象当成可迭代对象
        ```javascript
        function* nTimes(n) {
            while(n--) {
                yield;
            }
        }
        for (let _ of nTimes(3)) {
            console.log('foo');
        }
        ```
    - 上一次让函数暂停的`yield`关键字会接收到传给`next()`方法的第一个值
        - 第一次调用`next()`传入的值不会被使用
    - 可以用星号增强`yield`的行为，让它能够迭代一个可迭代对象
        ```javascript
        function* generatorFn() {
            yield*[1, 2, 3];
        }
        ```
    - 生成器对象除了`next()`以及可选的`return()`方法外，还具有`throw()`方法
        - `return()`方法会强制生成器进入关闭状态，提供给`return()`方法的值，就是终止迭代器对象的值
        - `throw()`方法将一个错误注入到生成器对象中。错误未被生成器函数内部处理，则关闭生成器

**对象属性**
- ECMA-262 使用一些内部特性描述属性的特征
- 分为数据属性和访问器属性两种
    - 数据属性会包含一个保存数据值的位置，值会从这个位置读取
        - 数据属性有四个特性描述它们的行为
        - 要修改属性的默认特性，必须使用`Object.defineProperty()`方法
    - 访问器属性不包含数据值。反而包含一个获取函数和一个设置函数
        - 访问器属性不能直接定义，必须使用`Object.defineProperty()`方法
    - 可以使用`Object.defineProperties()`一次性定义多个属性
    - 使用`Object.getOwnPropertyDescriptor()`方法可以取得指定属性的属性描述符

**合并对象**
- `Object.assign()`
    - 接收一个目标对象和一个或多个源对象作为参数
    - 将每个源对象中可枚举和自有属性复制到目标对象
    - 返回修改后的目标对象

**Object.is()**
- 类似全等操作符，但考虑到了一些边界情形
    ```javascript
    Object.is(+0, -0);  //false
    Object.is(+0, 0);   //true
    Object.is(-0, 0);   //false
    Object.is(NaN, NaN);    //true
    ```
- 要检查超过两个值，递归地利用相等性传递即可
    ```javascript
    function recursivelyCheckEqual(x, ...rest) {
        return Object.is(x, rest[0]) && (rest.length < 2 || recursivelyCheckEqual(...rest));
    }
    ```

**增强的对象语法**
- 属性值简写
    - 简写属性名只要使用变量名，就会自动被解释为同名的属性键
- 可计算属性
    - 中括号包裹的对象属性键告诉运行时将其作为表达式求解
- 简写方法名
    - 简写方法名对获取函数和设置函数适用
        ```javascript
        let person = {
            sayName(name) {
                console.log(`My name is ${name}`);
            },
            get name() {},
            set name() {}
        };
        ```
    - 简写方法名与可计算属性键相互兼容
- 对象解构
    - 使用与对象匹配的结构来实现对象属性赋值
        ```javascript
        let person = {
            name: 'Matt',
            age: 27
        };
        let {
            name: personName,
            age: personAge
        } = person;
        ```
    - 也可以使用简写语法
        ```javascript
        let {name, age} = person;
        ```
    - 可以在解构赋值的同时定义默认值
        ```javascript
        let {name, job='engineer'} = person;
        ```
    - 解构在内部使用函数`ToObject()`把源数据结构转换为对象
        - `null` 和 `undefined` 不能被解构，否则会抛出错误
    - 解构并不要求变量必须在解构表达式中声明， 但如果给事先声明的变量赋值，则赋值表达式必须包含在一对括号中
        ```javascript
        let personName, personAge;
        ({name: personName, age: personAge} = person);
        ```
    - 可以使用嵌套解构
        ```javascript
        let person = {
            job: {
                title: 'engineer'
            }
        }
        let { job: {title} } = person;
        ```
    - 在函数参数列表中也可以进行解构赋值

**工厂模式**
- 使用函数封装创建对象的代码
- 没有解决对象标识问题(新创建的对象是什么类型)

**构造函数**
- 要创建构造函数的实例，要使用`new`操作符
    1. 在内存中创建新对象
    2. 新对象内部的`[[Prototype]]`特性被赋值为构造函数的`prototype`属性
    3. 构造函数内部的`this`被赋值为这个新对象
    4. 执行构造函数内部的代码
    5. 如果构造函数不返回非空对象，则返回刚创建的新对象
- 创建的实例对象`constructor`属性指向构造函数
- 自定义构造函数可以确保实例被标识为特定类型
- 定义的方法会在每个实例上都创建一遍

**原型模式**
- 函数与其原型对象通过`prototype`和`constructor`属性相互引用
- 构造函数创建实例内部`[[Prototype]]`指针就会被赋值为构造函数的原型对象
- `instanceof`操作符和`isPrototype()`方法检查实例的原型链中是否包含指定构造函数的原型
- `Object.getPrototypeOf()`方法返回参数的内部特性`[[Prototype]]`的值
- `Object.setPrototypeOf()`方法可以向实例的私有特性`[[Prototype]]`写入一个新值
- `Object.create()`方法创建一个新对象，以参数对象作为原型
- 在访问对象属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身，如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象
    - 虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性。
- `hasOwnProperty()`方法在属性存在于调用它的对象实例上时返回`true`
- `Object.getOwnPropertyDescriptor()`方法只对实例属性有效
- `in`操作符
    - 在单独使用操作符时，只要属性能在对象上访问到，就返回`true`
    - 在 for-in 循环中使用`in`操作符时，可通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性
- `Object.keys()`接收一个对象作为参数，返回包含该对象所有可枚举的实例属性名称的字符串数组
- `Object.getOwnPropertyNames()`返回一个数组，列出所有实例属性，无论是否可以枚举
- `Object.getOwnPropertySymbols()`类似上一个方法，只是针对符号
- `Object.values()`, `Object.entries()`接收一个对象，返回它们内容的数组
    - 非字符串属性转换为字符串输出
    - 这两个方法执行浅复制
    - 符号属性会被忽略
- 原型的问题
    - 弱化了向构造函数传递初始化参数的能力
    - 共享特性

**原型继承**
- 原型链的问题
    - 使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性变成了共享的原型属性
    - 子类型在实例化时不能给父类型的构造函数传参
- 盗用构造函数
    - 使用`apply()`和`call()`方法以新创建的对象为上下文执行构造函数
        ```javascript
        function SuperType() {
            this.colors = ['red', 'blue', 'green'];
        }
        function SubType() {
            SuperType.call(this);
        }
        ```
    - 优点
        - 可以在子类构造函数中向父类构造函数传参
    - 缺点
        - 函数不能重用
        - 子类不能访问父类原型上定义的方法
- 组合继承
    - 使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性
        ```javascript
        function SubType(name, age) {
            SuperType.call(this, name);
            this.age = age;
        }
        SubType.prototype = new SuperType();
        SubType.prototype.sayAge = function() {};
        ```
- 寄生式继承
    - 盗用构造函数继承实例属性，使用父类原型的浅拷贝作为子类原型

**类**
- 与函数进行对比
    - 类似函数声明，定义类有类声明和类表达式两种
    - 函数声明可以提升，类声明不能
    - 函数受函数作用域限制，类受块作用域限制
- 类可以包含构造函数、实例方法、获取函数、设置函数和静态类方法
- 类表达式的名称是可选的，可以通过`name`属性取得类表达式的名称字符串
- 构造函数
    - `constructor`关键字用来在类定义块内部创建类的构造函数
    - 使用`new`操作符创建类的新实例时，调用构造函数
        1. 在内存中创建一个新对象
        2. 新对象内部的`[[Prototype]]`指针被赋值为构造函数的`prototype`属性
        3. 构造函数内部的`this`被赋值为这个新对象
        4. 执行构造函数内部的代码
        5. 在构造函数不返回非空对象的前提下返回刚创建的对象
    - 类实例化时传入的参数会用作构造函数的参数
    - 调用类构造函数时如果忘了使用`new`会抛出错误
- ECMAScript 类就是一种特殊函数
- 类标识符也有`prototype`属性，而这个原型也有一个`constructor`属性指向类自身
- 在构造函数内部添加实例属性
- 在类块中定义的方法作为原型方法
- 静态类成员在类定义中使用`static`关键字作为前缀。静态成员中，`this`引用类自身
- 类定义不显式支持在原型或类上添加成员数据，但在类外部，可以手动添加

**类的继承**
1. 继承基础
    - 使用`extends`关键字，就可以继承任何拥有`[[Construct]]`和原型的对象
    - 这意味着可以继承类和构造函数（保持向后兼容） 
    - 派生类会通过原型链访问到类和原型上定义的方法，`this`的值会反映调用相应方法的类
2. 构造函数、HomeObject 和 super()
    - 派生类的方法可以通过`super`关键字引用它们的原型。
    - 在类构造函数中使用`super`可以调用父类构造函数
    - 在静态方法中可以通过`super`调用继承的类上定义的静态方法
    - ES6 给类构造函数和静态方法添加了内部特性`[[HomeObject]]`，这个特性是一个指针，指向定义该方法的对象。`super`始终会定义为`[[HomeObject]]`的原型
    - 关于`super`
        - `super`只能在派生类构造函数和静态方法中使用
        - 不能单独引用`super`关键字，要么用它调用构造函数，要么用它引用静态方法
        - 调用`super()`会调用父类构造函数，并将返回的实例赋值给`this`
        - 如果在派生类中显式定义了构造函数，则要么必须在其中调用`super()`，要么必须在其中返回一个对象
3. 抽象基类
    - 可供其他类继承，但本身不会实例化
    - 通过实例化时检测`new.target`是不是抽象基类，可以阻止对抽象基类的实例化
    - 通过在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了
4. 继承内置类型
    - 有些内置类型的方法会返回新实例，默认情况下，返回实例的类型与原始类型一致
    - 如果想覆盖这个行为，可以覆盖`Symbol.species`访问器，这个访问器决定在创建返回实例时使用的类
        ```javascript
        class SuperArray extends Array {
            static get[Symbol.species]() {
                return Array;
            }
        }
        ```
5. 类混入
    - `Object.assign()`方法是为了混入对象行为设计的。只有在需要混入类的行为时才有必要自己实现混入表达式
    - 一种策略是定义一组可嵌套的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类
    - 很多 JavaScript 框架已经抛弃混入模式，转向了组合模式（把方法提取到独立的类和辅助对象中，然后把它们组合起来）

**代理与反射**

代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。

**代理基础**

从很多方面看，代理类似 C++ 指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象既可以直接操作，也可以通过代理来操作。但直接操作会绕过代理施予的行为。

1. 创建空代理
    - 代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象
    - 要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作都畅通无阻地抵达目标对象
    - `Proxy.prototype`是`undefined`，因此不能使用`instanceof`操作符
    - 严格相等可以区分代理与目标
2. 定义捕获器
    - 捕获器就是处理程序对象中定义的基本操作的拦截器。每个处理程序对象可以包含零个或多个捕获器，每个捕获器对应一种基本操作。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为
    - 可以定义一个`get()`捕获器，当通过代理对象执行 get 操作时，就会触发定义的`get()`捕获器
3. 捕获器参数和反射API
    - 所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。`get()`捕获器会接收到目标对象、要查询的属性和代理对象三个参数
    - 所有捕获器都可以基于自己的参数重建原始操作。实际上，开发者并不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上的同名方法轻松重建
    - 处理程序对象中所有可以捕获的方法都有对应的反射 API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，并且也具有与被拦截对象相同的行为
    - 反射 API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法
4. 捕获器不变式
    - 每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序必须遵循捕获器不变式。捕获器不变式因方法不同而异，但通常都会放置捕获器定义出现过于反常的行为
    - 目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError
5. 可撤销代理
    - Proxy 也暴露了`revocable()`方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的
6. 实用反射 API
    - 反射 API 并不限于捕获处理程序
    - 大多数反射 API 方法在 Object 类型上都有对应的方法
    - 很多反射方法返回称为状态标记的布尔值，表示意图执行的操作是否成功
    
代理可以捕获到十三种不同的基本操作

`get()`具有`target`、`property`和`reciver`三个参数

`set()`具有`target`、`property`、`value`和`receiver`四个参数

`has()`捕获器会在`in`操作符中被调用

使用代理模式可以做到跟踪属性访问、隐藏属性、属性验证、函数与构造函数参数验证、数据绑定与可观察对象