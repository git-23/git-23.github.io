# 函数

## 函数定义

可以使用函数声明、函数表达式（将变量赋值为匿名函数）、箭头函数和`Function`构造函数定义

箭头函数只有一个参数的情况，可以不使用括号，其他情况（包括没有参数）需要使用括号。在只有一行代码的时候，可以不使用大括号，但会隐式返回这行代码的值。箭头函数不能用作构造函数，不能使用`arguments`, `super`, `new.target`，也没有`prototype`属性

## 参数

JS 函数的参数在内部表现为一个数组，可以在函数内部访问`arguments`对象取得传入的每一个参数值（`arguments`对象是一个类数组对象）。`arguments`对象的`length`属性是实际传入参数的个数，函数对象的`length`属性是函数形参的个数（第一个具有默认值之前的形参个数）

命名参数和`arguments`对象存储在不同的位置，但它们的值会发生同步（严格模式下会有一些变化）

可以在参数后使用`=`为参数赋一个默认值（可以使用调用函数返回的值），给函数传`undefined`相当于没有传值，会使用默认值。`arguments`对象只反映传给函数的参数

给多个参数定义默认值实际上和使用`let`关键字顺序声明变量一样，后定义默认值的参数可以引用先定义的参数。参数存在于自己的作用域中，它们不能引用函数体的作用域

可以使用扩展操作符将数组的每一项作为参数传入函数中，也可以使用扩展操作符收集参数，将不同的独立参数组合为一个数组。收集参数不影响`arguments`对象


## 特殊对象

`arguments`对象的`callee`属性指向`arguments`对象所在函数，严格模式下访问`arguments.callee`会报错

在标准函数中`this`引用把函数当成方法调用的上下文对象。在箭头函数中，`this`引用的是定义箭头函数的上下文（在定时回调中，`this`值指向的并非想要的对象）

`caller`属性引用的是调用当前函数的函数，严格模式下给`caller`属性赋值会导致错误

函数使用`new`关键字调用时，`new.target`引用被调用的构造函数。正常调用`new.target`的值是`undefined`

## 属性和方法

`length`, `prototype`

`apply()`接收两个参数，函数内`this`的值和一个参数数组。`call()`方法与之类似，但参数是一个个传入的

`bind()`方法会创建一个新的函数实例，其`this`值会被绑定到传给`bind()`的对象

## 尾调用优化

尾调用指外部函数的返回值是一个内部函数的返回值，在这种情况下可以把外部函数栈帧弹出栈外

执行尾调用优化需要满足以下几个条件：

- 代码在严格模式下执行
- 外部函数返回值是对尾调用函数的调用
- 尾调用函数返回后不需要执行额外的逻辑
- 尾调用函数不是引用外部函数作用域中自由变量的闭包

之所以要求严格模式，主要因为非严格模式可以使用`arguments`和`caller`，它们会引用外部函数的栈帧

## 闭包

在定义函数的时候，就会为它创建作用域链，预装载全局变量对象，保存在内部的`[[Scope]]`中。在调用这个函数的时候，会创建相应的执行上下文，通过复制函数的`[[Scope]]`来创建其作用域链，然后会创建函数的活动对象并将其推入作用域链的前端

由于 IE 在 IE9 之前对 JScript 对象和 COM 对象使用了不同的垃圾回收策略，导致闭包在旧版本 IE 中可能会出现问题。存储在活动对象中的变量会始终获得一个引用，导致它不能被释放

## 立即调用的函数表达式

把函数声明放在括号中解释为表达式，后加的第二组括号会立即调用前面的函数表达式。在 ES6 之前 IIFE 的主要用途是模拟块级作用域

## 私有变量

可以定义特权方法供实例访问构造函数的私有成员，特权方法可以定义为实例方法或原型方法