# 函数

## 函数定义

可以使用函数声明、函数表达式（将变量赋值为匿名函数）、箭头函数和`Function`构造函数定义

箭头函数只有一个参数的情况，可以不使用括号，其他情况（包括没有参数）需要使用括号。在只有一行代码的时候，可以不使用大括号，但会隐式返回这行代码的值。箭头函数不能用作构造函数，不能使用`arguments`, `super`, `new.target`，也没有`prototype`属性

## 参数

JS 函数的参数在内部表现为一个数组，可以在函数内部访问`arguments`对象取得传入的每一个参数值（`arguments`对象是一个类数组对象）。`arguments`对象的`length`属性是实际传入参数的个数，函数对象的`length`属性是函数形参的个数（第一个具有默认值之前的形参个数）

命名参数和`arguments`对象存储在不同的位置，但它们的值会发生同步（严格模式下会有一些变化）

可以在参数后使用`=`为参数赋一个默认值（可以使用调用函数返回的值），给函数传`undefined`相当于没有传值，会使用默认值。`arguments`对象只反映传给函数的参数

给多个参数定义默认值实际上和使用`let`关键字顺序声明变量一样，后定义默认值的参数可以引用先定义的参数。参数存在于自己的作用域中，它们不能引用函数体的作用域

可以使用扩展操作符将数组的每一项作为参数传入函数中，也可以使用扩展操作符收集参数，将不同的独立参数组合为一个数组。收集参数不影响`arguments`对象


## 特殊对象

`arguments`对象的`callee`属性指向`arguments`对象所在函数，严格模式下访问`arguments.callee`会报错

在标准函数中`this`引用把函数当成方法调用的上下文对象。在箭头函数中，`this`引用的是定义箭头函数的上下文（在定时回调中，`this`值指向的并非想要的对象）

`caller`属性引用的是调用当前函数的函数，严格模式下给`caller`属性赋值会导致错误

函数使用`new`关键字调用时，`new.target`引用被调用的构造函数。正常调用`new.target`的值是`undefined`



